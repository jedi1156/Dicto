module.exports = function(opts){
	var queryUtil = require("queryUtil")
		,	util = require("util")
		,	clientFields = "word,type,explanation,pronunciation,chapter,important,learnt"
		,	statements = {
				createDB: "CREATE DATABASE IF NOT EXISTS " + opts.database + " CHARSET utf8;"
			,	useDB: "USE " + opts.database + ";"
			,	createWords: "CREATE TABLE IF NOT EXISTS words ("
				+	"  word VARCHAR(500) CHARSET utf8"
				+	", type VARCHAR(60) CHARSET utf8"
				+	", explanation TEXT CHARSET utf8 NOT NULL"
				+	", pronunciation VARCHAR(256) CHARSET utf8"
				+	", chapter INT"
				+	", important BOOL"
				+	", learnt INT"
				+	") CHARSET utf8;"
			,	createUsers: "CREATE TABLE IF NOT EXISTS users ("
				+ "  id INT UNSIGNED NULL AUTO_INCREMENT PRIMARY KEY"
				+	", user VARCHAR(100) CHARSET utf8 NOT NULL"
				+	", hash TEXT CHARSET utf8 NOT NULL"
				+	", salt CHAR(45) CHARSET utf8 NOT NULL"
				+	") CHARSET utf8;"
			
			,	showTables: "SHOW TABLES;"
			
			,	user: "SELECT * FROM users WHERE user="
			,	addUser: "INSERT INTO users (user,hash,salt) VALUE "
			,	delUser: "DELETE FROM users WHERE user="
			,	word: "SELECT " + clientFields + " FROM words WHERE word"
			,	expl: "SELECT " + clientFields + " FROM words WHERE REPLACE(explanation, '~', word)"
			, insertWord: "INSERT INTO words(" + clientFields + ") VALUES "
			,	modifyWord: "UPDATE words SET "
			,	learnWord: "UPDATE words SET learnt="
			,	deleteWord: "DELETE FROM words WHERE word="
			,	learnt: "learnt>=20"
			,	notLearnt: "learnt<20"
			, important: "important=TRUE"
			, notImportant: "important=FALSE"
			,	type: "type="
			,	general: "SELECT " + clientFields + " FROM words"
			,	orderByWord: " ORDER BY word"
			,	count: "SELECT COUNT(*) AS words FROM words"
			}
		,	defaultLimit = opts.limit || 100;
	
	function init(){
		return [
			statements.createDB
		,	statements.useDB
		,	statements.createUsers
		,	statements.createWords
		];
	}
	
	/**
		(string, string, options)
		
		OR
		
		([array of strings], options)
	*/
	function concatOptions(str1, str2, opts){
		if(str1 === ""){
			return str2;
		}else if(str2 === ""){
			return str1;
		}else{
			if(Object.prototype.toString.call(str1) == "[object Array]"){
				opts = str2 || {};
			}else{
				opts = opts || {};
				str1 = [str1, str2];
			}
			
			opts.operator = opts.operator || "AND";
			str1 = str1.join(" " + opts.operator + " ");
			
			if(opts.brackets){
				str1 = "(" + str1 + ")";
			}
			
			return str1;
		}
	}
	
	function getOptions(body){
		var qry;
		if(body.learnt === "0"){
			qry = statements.notLearnt;
		}else if(body.learnt != null){
			qry = statements.learnt;
		}else{
			qry = "";
		}
		
		if(body.important === "0"){
			qry = concatOptions(qry, statements.notImportant);
		}else if(body.important != null){
			qry = concatOptions(qry, statements.important);
		}
		
		if(body.type){
			qry = concatOptions(qry, statements.type + queryUtil.quoteStr(body.type));
		}
		
		return qry;
	}
	
	function arrToQuote(arr, unquoted){
		var res = []
			,	i;
		for(i = 0; i < arr.length; ++i){
			res[i] = queryUtil.quoteStr(arr[i]);
		}
		if(unquoted != null){
			res = res.concat(unquoted);
		}
		return res.join();
	}
	
	function insertQuery(word){
		var fieldArr = arrToQuote([word.word, word.type, word.explanation, word.pronunciation],
			[~~word.chapter, ~~word.important, ~~word.learnt]);
		return statements.insertWord + "(" + fieldArr + ");";
	}
	
	function minificateChapters(arr){
		var i
			,	j;
		
		arr = arr || [];
		
		if(arr.length){
			arr = arr.sort(function(a, b){
				if(a[0] === b[0]){
					if(a.length === 2 && b.length === 2){
						return a[1] - b[1];
					}else{
						return a.length - b.length;
					}
				}else{
					return a[0] - b[0];
				}
			});

			if(arr[0].length === 1){
				arr[0][1] = arr[0][0];
			}
			for(i = 0, j = 1; j < arr.length;){
				if(arr[j].length === 1){
					arr[j][1] = arr[j][0];
				}
				if(arr[i][1] + 1 >= arr[j][0]){
					arr[i] = [
						Math.min(arr[i][0], arr[j][0])
					,	Math.max(arr[i][1], arr[j][1])
					];
					arr.splice(j, 1);
				}else{
					i += 1;
					j += 1;
				}
			}
		}

		return arr;
	}
	
	var controlChapters = (function(){
		function compFunc(a, b){
			return a - b;
		}

		return function(arr){
			var i;
			
			for(i = 0; i < arr.length; ++i){
				arr[i].sort(compFunc);
			}
			
			return minificateChapters(arr);
		}
	})();
	
	function arrToChapters(arr){
		var i
			,	chaps = []
			,	and = { brackets: true }
			,	prop = "chapter";
		
		if(!arr){
			return "";
		}
		
		if(typeof arr === "string"){
			arr = JSON.parse(arr);
		}
		
		arr = controlChapters(arr);
		
		for(i = 0; i < arr.length; ++i){
			if(arr[i][0] === arr[i][1]){
				chaps.push(prop + "=" + arr[i][0]);
			}else{
				chaps.push(concatOptions(prop + ">=" + arr[i][0], prop + "<=" + arr[i][1], and));
			}
		}
		
		switch(chaps.length){
			case 0:
				return "";
			case 1:
				return chaps[0].replace(/[\(\)]/g, "");
			default:
				chaps = "(" + chaps.join(" OR ") + ")";
				return chaps;
		}
	}
	
	function bodyToOptions(body){
		var qry = "";
		if(body.chapters !== "all"){
			qry = arrToChapters(body.chapters);
		}
		return concatOptions(getOptions(body), qry);
	}
	
	function limitClause(limit){
		return "LIMIT " + (limit || defaultLimit);
	}
	
	function SQLreplace(inStr, whatStr, forStr){
		return "REPLACE(" + [inStr, whatStr, forStr].join() + ")";
	}
	
	function SQLlength(str){
		return "LENGTH(" + str + ")";
	}
	
	function SQLsubstring(str, pos, len){
		var args;
		if(!pos || (typeof pos != "number" && typeof pos != "string")){
			pos = 1;
		}
		if(typeof len != "number"
		&& typeof len != "string"
		&& typeof len != "undefined"
		&& !(~~len)){
			args = [].slice.call(arguments, 0, -1);
		}else{
			args = [].slice.call(arguments);
		}
		return "SUBSTR(" + args.join() + ")";
	}
	
	function chapterQuery(body){
		var qry = bodyToOptions(body);

		return concatOptions(statements.general, qry, { operator: "WHERE" }) + statements.orderByWord + ";";
	}
	
	function countQuery(body){
		var qry = bodyToOptions(body);

		return concatOptions(statements.count, qry, { operator: "WHERE" }) + ";";
	}
	
	function wordQuery(word){
		return statements.word + "=" + queryUtil.quoteStr(word) + ";";
	}
	
	var containQuery = (function(){
		function replaceWrapper(withStr){
			return SQLreplace("explanation", "'~'", withStr);
		}
		
		function replaceTrimmed(num){
			if(num < 1 || typeof num != "number" || isNaN(num)){
				num = 1;
			}
			return replaceWrapper(SQLsubstring("word", 1, SQLlength("word") + "-" + num));
		}
		
		var replaceStatement = (function(){
			var replaceArray = [
				"word"
			,	replaceWrapper("word")
			],	i;
			for(i = 1; i <= 5; ++i){
				replaceArray.push(replaceTrimmed(i));
			}
			replaceArray.forEach(function(item, i, arr){
				arr[i] += " LIKE ";
			});
			return function(quotedLike){
				var res = replaceArray.slice();
				res.forEach(function(item, i, arr){
					arr[i] += quotedLike;
				})
				return concatOptions(res, { operator: "OR", brackets: true });
			}
		})();
		
		function orderStatement(quoted){
			return "ORDER BY positionmin(POSITION(" + quoted
				+ " IN word), POSITION(" + quoted
				+ " IN explanation)), word";
		};
		
		return function(word, limit){
			var	quoted = queryUtil.quoteStr(word)
				,	quotedLike = queryUtil.quoteStrLike(word);
			return [statements.general + " WHERE"
				,	replaceStatement(quotedLike)
				,	orderStatement(quoted)
				,	limitClause(limit)
				].join(" ") + ";";
		}
	})();
	
	function deleteQuery(word){
		return statements.deleteWord + queryUtil.quoteStr(word) + ";";
	}
	
	function getUser(userId){
		return statements.user + queryUtil.quoteStr(userId) + ";";
	}
	
	function addUser(userId, password, salt){
		return statements.addUser + "(" + arrToQuote([userId, password, salt]) + ");";
	}
	
	function delUser(userId){
		return statements.delUser + queryUtil.quoteStr(userId) + ";";
	}
	
	function learnQuery(words){
		var i
			,	len;
		switch(Object.prototype.toString.call(words)){
			case "[object Object]":
				return statements.learnWord + words.learnt + " WHERE word=" + queryUtil.quoteStr(words.word) + ";";
				break;
			case "[object Array]":
				len = words.length;
				switch(len){
					case 0:
						return null;
					case 1:
						words = words[0];
						return statements.learnWord + words.learnt + " WHERE word=" + queryUtil.quoteStr(words.word) + ";";
					default:
						for(i = 0; i < len; ++i){
							words[i] = "WHEN " + queryUtil.quoteStr(words[i].word) + " THEN " + words[i].learnt;
						}
						words = words.join("\n");
						
						return statements.learnWord + "CASE word\n" + words + "\nELSE learnt\nEND;";
				}
				break;
			default:
				throw new Error("Bad arguments - neither an object {word, learnt}, nor an array of them!");
		}
	}
	
	function bodyImpoToSQLval(val){
		if(val === "true"
		|| ~~val){
			return "1";
		}else{
			return "0";
		}
	}
	
	function modifyQuery(body){
		return statements.modifyWord
			+	[
					"type=" + queryUtil.quoteStr(body.type)
				,	"explanation=" + queryUtil.quoteStr(body.explanation)
				,	"pronunciation=" + queryUtil.quoteStr(body.pronunciation)
				,	"chapter=" + body.chapter
				,	"important=" + bodyImpoToSQLval(body.important)
				].join(",")
			+	" WHERE word=" + queryUtil.quoteStr(body.word)
			+	";";
	}

	// return {
	// 	createDicto: function(){return statements.createDicto;}
	// ,	createWords: function(){return statements.createWords;}
	// ,	createUsers: function(){return statements.createUsers;}
	// ,	getUser: getUser
	// ,	addUser: addUser
	// ,	delUser: delUser
	// ,	insert: insertQuery
	// ,	modify: modifyQuery
	// ,	learn: learnQuery
	// ,	word: wordQuery
	// ,	contain: containQuery
	// ,	chapter: chapterQuery
	// ,	count: countQuery
	// ,	del: deleteQuery
	// };

	function insertBackup (words) {
		var arr = [];

		words.forEach(function(it, id, words) {
			arr.push(insertQuery(it));
		});

		return arr;
	}

	var queries = {
				init: init
			,	showTables: function(){ return statements.showTables; }
			,	getUser: getUser
			,	addUser: addUser
			,	delUser: delUser
			,	insert: insertQuery
			,	modify: modifyQuery
			,	learn: learnQuery
			,	word: wordQuery
			,	contain: containQuery
			,	chapter: chapterQuery
			,	count: countQuery
			,	del: deleteQuery
			,	insertBackup: insertBackup
			};

	return function(type, args){
		var func = queries[type];
		if(typeof func == "function"
		&& queries.hasOwnProperty(type)){
			return func.apply(null, args);
		}else{
			throw "queries> Invalid query type: " + type;
		}
	};
	
};

/** This is module to store sessions of logged users
	*	Usage:
	*		var sessionStore({
	*			int reapInterval,
	*			object store,
	*			function hashGenerator
	*		});
	*			reapInterval - after that much time of inactivity of a logged user, the user is automatically logged out; -1 - don't logout automatically; default - 60000 * 10 (10 min)
	*			store - "redis" OR function({ int reapInterval, some other params... }) returning store object, that HAS to have following methods (default to JS native memory store):
	*				get(id, callback) - runs callback with the value of id - a {userId, hash} object or null
	*				set({userId, hash}, callback) - sets value of userId to hash, callback()
	*				touch(hash, callback) - sets again timeout to delete hash
	*				del(id, callback) - deletes value from store and evokes callback()
	*				clear(callback) - deletes all values, callback()
	*			hashGenerator - asynchronously generating random string
	*				default to crypto.randBytes(512) and next: random.toString("hex")
	*
	*		app.use(sessionStore.authenticate)
	*			Sets req.logged to either user name or false			
	*			if session cookie doesn't match (it kills it then),
	*			or if it's just not there.
	*			Use after cookieParser.
	*		
	*		sessionStore.newSession(req, res, next)
	*			req - express, I need only req.body.userId
	*			res - of the express middleware
	*			next - completing the express middleware
	*		! Use authenticate before if you want to end current session
	*
	*		sessionStore.endSession(req, res, next)
	*			A valid express middleware
	*			req, res - express stuff
	*			next - callback to call after
	*		! For this one to work you have to use authenticate before
	*
	*		sessionStore.endAll(callback)
	*			store.clear(callback), no args passed
	*
	*		sessionStore.kick(userId, callback)
	*/
module.exports = function(opts){
	opts = opts || {};
	var store
		,	hashGenerator
		,	crypto;
	
	opts.reapInterval = opts.reapInterval || 60000 * 10;
	
	if(typeof opts.hashGenerator == "function"){
		hashGenerator = opts.hashGenerator;
	}else{
		crypto = require("crypto");
		hashGenerator = defaultHashGenerator;
	}
	
	if(typeof opts.store == "function"){
		store = opts.store;
	}else if(opts.store === "redis"){
		store = require("./lib/redisPlug");
	}else{
		store = require("./lib/defaultPlug");
	}
	
	store = store(opts);
	if(!testStore(store)){
		throw "sessionStore> Invalid store object!";
	}
	
	function authenticate(req, res, next){
		var cookie = req.cookies["logged-user-id"];
		next = next || function(){};
		if(cookie){
			store.get(cookie.userId, function(hash){
				if(cookie.hash === hash){
					req.logged = cookie.userId;
					store.touch(cookie.userId);
				}else{
					req.logged = false;
					killCookie(res);
				}
				next();
			});
		}else{
			req.logged = false;
			next();
		}
	}
	
	function endSession(req, res, next){
		var cookie = req.cookies["logged-user-id"];
		next = next || function(){};
		if(req.logged){
			killCookie(res);
			store.del(cookie.userId, next);
		}else{
			next();
		}
	}
	
	function newSession(req, res, next){
		endSession(req, res, function(){
			hashGenerator(function(hash){
				var obj = {
					userId: req.body.userId
				,	hash: hash
				};
				res.cookie("logged-user-id", obj, {
					expires: false
				,	httpOnly: true
				});
				store.set(obj, next);
			});
		});
	}
		
	return {
		authenticate: authenticate
	,	newSession: newSession
	,	endSession: endSession
	,	endAll: store.clear
	,	kick: store.del
	};
	
	function killCookie(res){
		res.cookie("logged-user-id", "This phoney bastard expires here and now!", {
			maxAge: -10000
		,	httpOnly: true
		});
	}
	
	function testStore(store){
		return !!store
		&& [store.get
			,	store.set
			,	store.del
			,	store.touch
			].every(function(item, id, arr){
				return typeof item == "function" && item.length === 2;
			})
		&& typeof store.clear == "function"
		&& store.clear.length === 1;
	}
	
	function defaultHashGenerator(cb){
		crypto.randomBytes(512, function(ex, buf){
			cb(buf.toString("hex"));
		});
	}
};

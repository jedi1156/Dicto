/**	Here I gathered various methods
	* that are valuable while creating
	*	queries:
	*
	*		quoteStr(string str, object opts)
	*			Wraps str into '' quotes
	*			opts.pre * opts.post - what to add between ' and str
	*			opts.escapeAll - escape also _ and %, e.g. for SELECT queries
	*
	*		quoteLike(string str, object opts)
	*			Wrapper on the quoteStr that adds % pre and post, if they're not already set to that char
	*
	*		concatStatements(string str1, string str2, object opts) OR		
	*		concatStatements([str1, str2, str3, ...], object opts)
	*			Concats strings that are parts of SQL query
	*			with given operator defaulting to AND
	*			opts.operator - e.g. "OR", "LIKE", "WHERE", whatever you like to stand between strings
	* 		opts.dontAddSpaces - normally operator has spaces added, like "OR" ---> " OR "; if you're doing something strange, eg. using " OR id=" as an operator, you might want not to have them attached
	*			opts.brackets - if you wish to wrap returned statement in brackets
	*/

module.exports = (function(){
	var util = require("util")
		,	reg = {
				surname: /(?:\s)?([^\s]+)$/
			,	authorsSplit: /(?:(?:\s+i\s+)|(?:\s+oraz\s+)|(?:\s*,\s*))/
			,	tagsSplit: /\s*,\s*/
			};
	
	return {
		quoteStr: quoteStr
	,	quoteStrLike: quoteStrLike
	,	reduceNjoin: reduceNjoin
	,	quoteValues: quoteValues
	,	quote: {
			person: quotePerson
		,	tag: quoteStr
		}
	,	SQL: {
			concatStatements: SQLconcatStatements
		,	caseStatement: SQLcaseStatement
		,	replace: SQLreplace
		,	length: SQLlength
		,	substring: SQLsubstring
		,	escape: SQLescape
		}
	,	parse: {
			authors: parseAuthors
		,	tags: parseTags
		,	reduceTags: reduceTags
		,	linkifyTags: linkifyTags
		,	translateType: translateType
		}
	,	compare: {
			persons: comparePersons
		,	unique: uniqueComp
		,	strings: compareStrings
		}
	,	protoName: protoName
	,	unique: unique
	,	getTagTable: getTagTable
	};

	function quoteStr(str, opts){
		opts = opts || {};
		opts.pre = opts.pre || "";
		opts.post = opts.post || "";
		
		opts.pre = "'" + opts.pre;
		opts.post += "'";
		
		str = SQLescape(str);
		
		if(opts.escapeAll){
			str = str.replace(/_/g, "\\_").replace(/%/g, "\\%");
		}
		return opts.pre + str + opts.post;
	}
	
	function quoteStrLike(str, opts){
		opts = opts || {};
		if(opts.pre != null){
			if(opts.pre !== "%"){
				opts.pre = "%" + opts.pre;
			}
		}else{
			opts.pre = "%";
		}
		
		if(opts.post != null){
			if(opts.post !== "%"){
				opts.post += "%";
			}
		}else{
			opts.post = "%";
		}
		
		return quoteStr(str, opts);
	}
	
	function reduceNjoin(arr, func, joinArg){
		joinArg = joinArg || ",";
		func = func || function(){};
		return arr.reduce(func, 0).join(joinArg);
	}
	
	function quoteValues(arr, quoteValue){
		return "(" + reduceNjoin(arr, function(prev, the, idx, arr){
			arr[idx] = quoteValue(the);
			return arr;
		}, "),(") + ")";
	}
	
	function quotePerson(peer){
		return quoteStr(peer.fName) + "," + quoteStr(peer.sName);
	}

	function SQLconcatStatements(str1, str2, opts){
		if(str1 === ""){
			return str2;
		}else if(str2 === ""){
			return str1;
		}else{
			if(util.isArray(str1)){
				opts = str2 || {};
			}else{
				opts = opts || {};
				str1 = [str1, str2];
			}
			
			opts.operator = opts.operator || "AND";
			if(!opts.dontAddSpaces){
				opts.operator = " " + opts.operator + " ";
			}
			str1 = str1.join(opts.operator);
			
			if(opts.brackets){
				str1 = "(" + str1 + ")";
			}
			
			return str1;
		}
	}
	
	function SQLcaseStatement(caseWhat, pairs, elseVal){
		var i
			,	len
			,	res = "CASE";
		
		if(arguments.length === 2){
			pairs = caseWhat;
			caseWhat = "";
		}
		
		if(caseWhat){
			res += " " + caseWhat;
		}
		res += " ";
		
		for(i = 0, len = pairs.length; i < len; ++i){
			res += ["WHEN", pairs[i].when, "THEN", pairs[i].then].join(" ") + " ";
		}
		res += ["ELSE", elseVal, "END"].join(" ");
		
		return "(" + res + ")";
	}
	
	function SQLreplace(inStr, whatStr, forStr){
		return "REPLACE(" + [inStr, whatStr, forStr].join() + ")";
	}
	
	function SQLlength(str){
		return "LENGTH(" + str + ")";
	}
	
	function SQLsubstring(str, pos, len){
		var args;
		if(!isNumber(pos) || isZero(pos)){
			pos = 1;
		}
		if(!isNumber(len) || isZero(len)){
			args = [str, pos, len]
		}else{
			args = [str, pos]
		}
		return "SUBSTR(" + args.join() + ")";
	}
	
	function SQLescape(str){
		return str.replace(/\\/g, "\\\\")
			.replace(/\x00/g, "\\0")
			.replace(/\n/g, "\\n")
			.replace(/\r/g, "\\r")
			.replace(/\t/g, "\\t")
			.replace(/\x08/g, "\\b")
			.replace(/'/g, "\\'")
			.replace(/"/g, "\\\"")
			.replace(/\x1a/g, "\\Z");
	}
	
	/**	Private methods:
		*		isNumber(arg) - check if arg is not NaN number or  convertable string
		*		isZero(arg) - anything that converts to "0" string
		*/
	
	function isNumber(arg){
		return (typeof arg == "number"
			&& !isNaN(arg))
		|| (typeof arg == "string"
			&& (arg === "0" || ~~arg));
	}
	
	function isZero(arg){
		return arg.toString() === "0";
	}
	
	function parseAuthors(authors){
		var i
			,	len
			,	fName
			,	sName
			,	res = []
			,	parsed;
		if(authors && typeof authors === "string"){
			parsed = authors.trim().split(reg.authorsSplit);
			for(i = 0, len = parsed.length; i < len; ++i){
				parsed[i] = parsed[i].trim();
				sName = reg.surname.exec(parsed[i]);
				if(sName){
					fName = parsed[i].slice(0, sName.index).trim();
					res.push({
						fName: fName
					,	sName: sName[1]
					})
				}
			}
		}
		return res;
	}
	
	function parseTags(tags){
		if(tags && typeof tags === "string"){
			return tags.trim().split(reg.tagsSplit);
		}else{
			return [];
		}
	}
	
	function reduceTags(tags, linkify){
		var res = [];
		tags.forEach(function(tag, idx, arr){
			res.push(tag.name);
		});
		if(linkify){
			return linkifyTags(res).join(" ");
		}else{
			return res;
		}
	}
	
	function linkifyTags(tagList){
		var i
			,	len;
		for(i = 0, len = tagList.length; i < len; ++i){
			tagList[i] = "<a href=\"/search?tag=" + tagList[i] + "\">" + tagList[i] + "</a>";
		}
		return tagList;
	}
	
	function comparePersons(a, b){
		var asName = a.sName.toLowerCase()
			,	bsName = b.sName.toLowerCase()
			,	afName = a.fName.toLowerCase()
			,	bfName = b.fName.toLowerCase();
			
		if(asName === bsName){
			if(afName === bfName){
				return 0;
			}else if(afName < bfName){
				return -1;
			}else{
				return 1;
			}
		}else if(asName < bsName){
			return -1;
		}else{
			return 1;
		}
	}
	
	function compareStrings(a, b){
		if(a === b){
			return 0;
		}else if(a < b){
			return -1;
		}else{
			return 1;
		}
	}
	
	function protoName(arg){
		return Object.prototype.toString.call(arg);
	}
	
	function uniqueComp(a, b){
		var type = typeof a
			,	i;
		if(type !== typeof b){
			return false;
		}else{
			switch(type){
				case "number":
					return a === b ||
						(isNaN(a) && isNaN(b));
				case "object":
					type = protoName(a);
					if(type === protoName(b)){
						switch(type){
							case "[object Array]":
								type = a.length;
								if(type !== b.length){
									return false;
								}
								for(i = 0; i < type; ++i){
									if(!uniqueComp(a[i], b[i])){
										return false;
									}
								}
								return true;
							case "[object Object]":
								for(i in a){
									if(!uniqueComp(a[i], b[i])){
										return false;
									}
								}
								return true;
							case "[object RegExp]":
								return a.toString() === b.toString();
							default:
								return a === b;
						}
					}else{
						return false;
					}
				default:
					return a === b;
			}
		}
	}
	
	function unique(arr){
		var res = []
			,	i;
		
		if(arr.length){
			res.push(arr[0]);
			for(i = 1; i < arr.length; ++i){
				if(!uniqueComp(arr[i], arr[i - 1])){
					res.push(arr[i]);
				}
			}
		}
		
		return res;
	}
	
	
	function getTagTable(type){
		switch(type){
			case "Zines":
				return {
					table: "ZineTags"
				,	idField: "zineId"
				};
			case "Items":
				return {
					table: "ItemTags"
				,	idField: "itemId"
				};
			case "Texts":
				return {
					table: "TextTags"
				,	idField: "textId"
				};
			default:
				return null;
		}
	}
	
	function translateType(type){
		switch(type.toLowerCase()){
			case "article":
				return "Artykuł";
			case "essay":
				return "Esej";
			case "comics":
				return "Komiks";
			case "news":
				return "News";
			case "poesy":
				return "Poezja";
			case "relation":
				return "Relacja";
			case "interview":
				return "Wywiad";
			case "story":
				return "Opowiadanie";
			case "picture":
				return "Obrazek";
		}
	}
})();

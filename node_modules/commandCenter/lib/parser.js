module.exports = function(opts){
	var util = require("util")
		,	exe = {
				status: true
			,	stack: []
			,	RPN: []
			,	RPNidx: 0
			,	op: null
			,	opArgs: []
			, opIdx: 0
			,	ops: {
					"*": createOperator(opMult, 11)
				,	"%": createOperator(opMod, 11)
				,	"/": createOperator(opDiv, 11)
				,	"+": createOperator(opPlus, 10)
				,	"-": createOperator(opMinus, 10)
				,	"&&": createOperator(opAnd, 4)
				,	"||": createOperator(opOr, 3)
				,	",": createOperator(opComma, 2)
				,	";": createOperator(opSemiCol, 1)
				}
			}
		,	wordExp = /(?:")([^"]*)(?:")|(?:')([^']*)(?:')|(?:\s*)(([1-9]\d*|\d)([.]\d*)?|[\dA-Za-z\u00C0-\u1FFF\u2800-\uFFFD]+)(?:\s*)|(?:\s*)(\(|\)|[!-\/:-@\[-`{-~]+)(?:\s*)/g
		, wordExpLen = wordExp.exec("test").length
		,	operExp
		,	manySemiCollons = /;{2,}/g
		,	manyCommas = /,{2,}/g
		,	numberExp = /^([1-9]\d*|\d)([.]\d*)?$/
		,	cmds = opts.cmds
		,	stdin = process.stdin
		,	stdout = process.stdout
		,	stdinUtils = require("stdinUtils");

	wordExp.lastIndex = 0;
	operExp = (function(ops){
		var opsArr = ["^(\\(|\\)"]
			,	i
			, lastIdx = wordExpLen - 1;
		for(i in ops){
			if(typeof ops[i] == "function"
			&& Object.hasOwnProperty.call(ops, i)
			&& wordExp.exec(i)[lastIdx]){
				opsArr.push(i.replace(/\\/g, "\\\\")
					.replace(/\{/g, "\\{")
					.replace(/\}/g, "\\}")
					.replace(/\[/g, "\\[")
					.replace(/\]/g, "\\]")
					.replace(/[\|]/g, "[\\|]")
					.replace(/[*]/g, "[*]")
					.replace(/[+]/g, "[+]")
					.replace(/[$]/g, "[$]")
					.replace(/\^/g, "[\\^]")
				);
			}
			wordExp.lastIndex = 0;
		}
		
		opsArr.push("&)$");
		return RegExp(opsArr.join("|"));
	})(exe.ops);

	return flowManager;
	
	function parseCommand(){
		stdinUtils.getLine(function(data){
			try{
				parse(data);
				flowManager(true);
			}catch(err){
				console.log(err);
				wordExp.lastIndex = 0;
				flowManager(false);
			}
		});
	}
	
	function parse(data){
		exe.RPN = createRPN(commandify(wordify(data)));
	}
	
	function wordify(data){
		var res = []
			,	next
			,	i;
		
		data = data.replace(manySemiCollons, ";")
			.replace(manyCommas, ",");
		while((next = wordExp.exec(data))){
			for(i = 1
			; i < wordExpLen && next[i] == null
			;	++i);
			if(i + 1 === wordExpLen
			&& !operExp.exec(next[i])){
				if(next[i][0] === "&"
				&& next[i].length === 2
				&& /,|;/.exec(next[i][1])){
					res.push("&");
					res.push(next[i][1]);
				}else{
					throw new Error("Unknown operator: " + next[i]);
				}
			}else{
				next[i] = next[i].replace(/\\t/g, "\t")
					.replace(/\\n/g, "\n")
					.replace(/\\r/g, "\r");
				res.push(next[i]);
			}
		}
		
		return res;
	}
	
	function commandify(data){
		var res = []
			,	i
			,	len
			,	last
			,	notLastLen;

		if(data.length > 0){
			res.push([]);
			for(i = 0, len = data.length, last = 0; i < len; ++i){
				if(operExp.exec(data[i])
				&& data[i] !== "&"){
					notLastLen = !res[last].length;
					if(!(res[last - 1] === ";"
						&& data[i] === ";"
						&& notLastLen)){
							if(notLastLen){
								res.pop();
							}
							last = res.push(data[i]);
							res.push([]);
					}
				}else{
					res[last].push(data[i]);
				}
			}
			if(!res[last].length){
				res.pop();
			}
		}
		return res;
	}
	
	function createRPN(data){
		var res = []
			,	stack = exe.stack = []
			,	i
			,	len
			,	symb
			,	op
			,	symbFunc
			,	opFunc
			,	comp;
		
		for(i = 0, len = data.length; i < len; ++i){
			symb = data[i];
			switch(type(symb)){
				case "boolean":
					if(util.isArray(symb)){
						symb = symb[0].toString();
					}
				case "number":
				case "command":
					res.push(symb);
					break;
				case "operator":
					if(symb === "("){
						stack.push(symb);
					}else if(symb === ")"){
						op = stack.pop();
						while(op !== "("){
							if(op){
								res.push(op);
							}else{
								throw new Error("createRPN> Bracket mismatch: ) at word: " + i);
							}
							op = stack.pop();
						}
					}else{
						symbFunc = exe.ops[symb];
						if(symbFunc.assoc === "left"){
							comp = le;
						}else{
							comp = lt;
						}
						symbFunc = symbFunc.prio;
						while((op = stack[stack.length - 1])
						&& (opFunc = exe.ops[op])
						&& comp(symbFunc, opFunc.prio)){
							res.push(stack.pop());
						}
						
						stack.push(symb);
					}
					break;
				default:
					throw new Error("createRPN> Unknown token: " + symb);
			}
		}
		for(op = stack.pop(); op; op = stack.pop()){
			if(op === "(" || op === ")"){
				throw new Error("createRPN> Bracket mismatch: " + op + " at stack unloading");
			}
			res.push(op);
		}

		return res;
	}
	
	function executeWrapper(args){
		try{
			if(args[0]){
				if(!Object.hasOwnProperty.call(cmds, args[0])){
					args.unshift("exec");
				}
				if(args[args.length - 1] === "&"){
					executeCommandAsync(args);
				}else{
					executeCommand(args);
				}
			}else{
				passContr(true);
			}
		}catch(err){
			console.log(err);
			flowManager(false);
		}
	}
	
	function executeCommand(args){
		try{
			cmds[args[0]](args, passContr);
		}catch(err){
			console.log(err);
			passContr(false);
		}
	}

	function executeCommandAsync(args){
		try{
			setTimeout(function(){
				try{
					cmds[args[0]](args, logAsync);
				}catch(err){
					console.log(err);
				}
			}, 0);
		}catch(err){
			console.log(err);
		}
		passContr(true);
	}
	
	function logAsync(arg){
		console.log("\nasync: " + arg);
	}
	

	function flowManager(status){
		setTimeout(function(){
			var comm;
			try{
				if(exe.op){
					comm = executeOperator(exe.op);
					if(comm.type == "command"){
						executeWrapper(comm.res);
					}else{
						exe.op = null;
						exe.opArgs = [];
						if(comm.type != "void"){
							exe.stack.push(comm.res);
						}
						flowManager(comm.res);
					}
				}else if(exe.RPNidx < exe.RPN.length){
					comm = exe.RPN[exe.RPNidx];
					while(type(comm) != "operator"
					&& exe.RPNidx < exe.RPN.length){
						exe.stack.push(comm);
						exe.RPNidx += 1;
						comm = exe.RPN[exe.RPNidx];
					}
					exe.RPNidx += 1;
					if(!comm){
						comm = ";";
					}
					exe.op = comm;
					flowManager(true);
				}else	if(exe.stack.length){
					exe.op = ";";
					flowManager(true);
				}else{
					if(exe.RPN.length){
						try{
							if(typeof exe.status != "string"){
								exe.status = JSON.stringify(exe.status);
							}
						}finally{
							console.log(" <-\t" + exe.status);
							clearExe(exe);
						}
					}
					stdout.write(opts.prompt);
					parseCommand();
				}
			}catch(err){
				console.log(err);
				clearExe(exe);
				flowManager(false);
			}
		}, 0);
	}
	
	function passContr(arg){
		exe.status = arg;
		flowManager(arg);
	}
	
	/**	This function either returns true/false value
		*	OR returns command to call
		*/
	function executeOperator(op){
		var res
			,	opFunc = exe.ops[op]
			,	status;
		
		if(exe.opArgs.length === 0){
			while(exe.opArgs.length < opFunc.len){
				res = exe.stack.pop();
				if(res === undefined){
					if(op === ";"){
						break;
					}else{
						throw new Error("executeOperator> Too few arguments, got " + exe.opArgs.length + ", while " + opFunc.len + " needed.");
					}
				}
				exe.opArgs.push(res);
			}
			exe.opIdx = opFunc.len - 1;
		}else{
			status = exe.status;
			if(type(status) == "command"){
				status = JSON.stringify(status);
			}
			exe.opArgs[exe.opIdx] = status;
			exe.opIdx -= 1;
		}
		
		res = opFunc(exe.opArgs);
		
		res.type = res.type || type(res.res);
		return res;
	}
	
	function createOperator(func, prio, assoc, len){
		if(typeof func != "function"){
			throw new Error("createOperator> This is not a function: " + func);
		}
		func.prio = ~~prio;
		if(assoc == "right"){
			func.assoc = "right";
		}else{
			func.assoc = "left";
		}
		func.len = ~~len || 2;
		return func;
	}
	
	function findComm(args, transform){
		var arg;
		
		transform = transform || function(a){ return a; };

		for(arg = args[exe.opIdx]; exe.opIdx >= 0; exe.opIdx -= 1, arg = args[exe.opIdx]){
			if(type(arg) == "command"){
				return {
					res: arg
				,	type: "command"
				};
			}
			args[exe.opIdx] = transform(arg, exe.opIdx, args);
			if(arg != null){
				exe.status = arg;
			}
		}
		return null;
	}
	
	function opSemiCol(args){
		var comm = findComm(args);
		if(comm){
			return comm;
		}
		
		return {
			res: exe.status
		,	type: "void"
		}
	}
	
	function opAnd(args){
		var comm = args[1];
		if(type(comm) == "command"){
			return {
				res: comm
			,	type: "command"
			};
		}else if(castBoolean(comm) === false){
			return {
				res: comm
			};
		}else{
			return {
				res: args[0]
			};
		}
	}
	
	function opOr(args){
		var comm = args[1];
		if(type(comm) == "command"){
			return {
				res: comm
			,	type: "command"
			};
		}else if(castBoolean(comm) === true){
			return {
				res: comm
			};
		}else{
			return {
				res: args[0]
			};
		}
	}

	function opComma(args){
		var comm = findComm(args);
		if(comm){
			return comm;
		}
		
		return {
			res: args[0]
		};
	}
	
	function opPlus(args){
		var comm = findComm(args, castNumber);
		
		if(comm){
			return comm;
		}
		
		return {
			res: castNumber(args[1]) + castNumber(args[0])
		,	type: "number"
		}
	}
	
	function castNumber(arg){
		switch(type(arg)){
			case "number":
				if(util.isArray(arg)){
					arg = arg[0];
				}
				arg = JSON.parse(arg);
				break;
			case "boolean":
				if(util.isArray(arg)){
					arg = arg[0];
				}
				if(!arg || arg === "false"){
					arg = 0;
				}else{
					arg = 1;
				}
				break;
			default:
				throw new Error("cast error: " + arg + " is not a number");
		}
		return arg;
	}
	
	function castBoolean(arg){
		switch(type(arg)){
			case "number":
				if(util.isArray(arg)){
					arg = arg[0];
				}
				arg = !!JSON.parse(arg);
				break;
			case "boolean":
				if(util.isArray(arg)){
					arg = arg[0];
				}
			default:
				if(!arg || arg === "false"){
					arg = false;
				}else{
					arg = true;
				}
		}
		return arg;
	}
	
	function opMinus(args){
		var comm = findComm(args, castNumber);
		
		if(comm){
			return comm;
		}
		
		return {
			res: castNumber(args[1]) - castNumber(args[0])
		,	type: "number"
		}
	}
	
	function opMult(args){
		var comm = findComm(args, castNumber);
		
		if(comm){
			return comm;
		}
		
		return {
			res: castNumber(args[1]) * castNumber(args[0])
		,	type: "number"
		}
	}
	
	function opMod(args){
		var comm = findComm(args, castNumber);
		
		if(comm){
			return comm;
		}
		
		return {
			res: castNumber(args[1]) % castNumber(args[0])
		,	type: "number"
		}
	}
	
	function opDiv(args){
		var comm = findComm(args, castNumber);
		
		if(comm){
			return comm;
		}
		
		return {
			res: castNumber(args[1]) / castNumber(args[0])
		,	type: "number"
		}
	}
	
	function type(arg){
		if(util.isArray(arg)){
			if(arg.length === 1){
				arg = type(arg[0]);
				switch(arg){
					case "boolean":
					case "number":
						return arg;
				}
			}
			return "command";
		}else if(typeof arg == "boolean"
		|| arg === "true"
		|| arg === "false"){
			return "boolean"
		}else if(arg === null){
			return "void";
		}else if(operExp.exec(arg)){
			return "operator";
		}else if(numberExp.exec(arg)){
			return "number";
		}else{
			return "unknown";
		}
	}
	
	function lt(a, b){
		return a < b;
	}

	function le(a, b){
		return a <= b;
	}
	
	function clearExe(ex){
		ex.RPN = [];
		ex.RPNidx = 0;
		ex.op = null;
		ex.opArgs = [];
		ex.stack = [];
	}
}

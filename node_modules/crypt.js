/**	This module has four simple methods:
	*		encrypt(pass, callback) - generate password and salt
	*			callback({ hash, salt });
	*		isPassword(sentPass, storedPass, storedSalt, callback) - check if password is correct
	*			callback(true/false);
	*		loseTime(callback) - if there is no such client don't give a clue that it's about that, only "login OR password" is invalid
	*			callback()
	*		random(length)
	*			length - default to saltLength; int, or "hashLength"
	*
	*		WARNING! Callbacks are strictly required
	*
	*	Options
	*		hashLength - default 128
	*		saltLength - default 32
	*		rounds - default 1024
	*		encoding - default "base64"
	*/

module.exports = function(options){
	options = options || {};
	var crypto = require("crypto")
		,	opts = {
				hashLength: options.hashLength || 128
			,	rounds: options.rounds || 1024
			,	saltLength: options.saltLen || 32
			,	encoding: options.encoding || "base64"
			}
		,	queryUtil = require("queryUtil");

	return {
		encrypt: encrypt
	,	isPassword: isPassword
	,	loseTime: loseTime
	,	random: random
	};
	
	function cryptFunc(pass, salt, callback){
		crypto.pbkdf2(pass, salt, opts.rounds, opts.hashLength, function(err, key){
			if(err){
				throw err;
			}else{
				callback(key.toString(opts.encoding));
			}
		});
	}
	
	function random(len){
		if(len === "hashLength"){
			len = opts.hashLength;
		}else{
			len = len || opts.saltLength;
		}
		return crypto.randomBytes(len).toString(opts.encoding);
	}
	
	function encrypt(password, callback){
		var rand = random();
		cryptFunc(password, rand, function(key){
			callback({
				hash: key
			,	salt: rand
			});
		});
	}

	function isPassword(givenPass, storedPass, storedSalt, callback){
		cryptFunc(givenPass, storedSalt, function(key){
// 			for(var i = 0, len = key.length; i < len; ++i){
// 				console.log("" + i + ":\t" + key.charCodeAt(i) + "\tkey: " + key.charAt(i) + " \tsP: " + storedPass.charAt(i));
// 			}
// 			console.log("key: " + key.length + "\tsP: " + storedPass.length);
			callback(key === storedPass);
		});
	}
	
	function loseTime(callback){
		var rand = random("hashLength")
			,	rand2 = random();
		cryptFunc(rand, rand2, callback);
	}
	
	function halfEscape(str){
		return str.replace(/\x1a/g, "\\Z")
				.replace(/\x00/g, "\\0");
	}
};
